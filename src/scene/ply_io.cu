#include "scene/ply_io.cuh"
#include <fstream>
#include <bit>
#include <thrust/host_vector.h>

void save_to_ply(const std::filesystem::path& path,
    const DeviceBuffer<float>& xs, const DeviceBuffer<float>& ys,
    const DeviceBuffer<float>& zs)
{
    // create output file stream
    std::ofstream out(path);
    // find number of particles to write
    const size_t N { xs.size() };
    if (ys.size() != N || zs.size() != N) {
        throw std::runtime_error(
            "save_to_ply called on buffers with differing sizes");
    }

    // detect the native endianess of the system
    if (std::endian::native != std::endian::little
        && std::endian::native != std::endian::big) {
        throw std::runtime_error(
            "system uses mixed endianess so `save_to_ply` is confused about "
            "which endianess tow write the data in");
    }
    const auto endianess
        = std::endian::native == std::endian::little ? "little" : "big";

    // create header and write it to the file
    out << std::format(R"PLY_HEADER(ply
format binary_{}_endian 1.0
comment This PLY file was automatically generated by REYN to export a collection of 3D particle positions
element vertex {}
property float32 x
property float32 y
property float32 z
end_header
)PLY_HEADER",
        endianess, N);

    // load data to a host-side buffer
    thrust::host_vector<float> hxs = xs.get();
    thrust::host_vector<float> hys = ys.get();
    thrust::host_vector<float> hzs = zs.get();
    for (size_t i { 0 }; i < N; ++i) {
        // transpose the SoA order, i.e. write x_i, y_i, z_i
        out.write(reinterpret_cast<const char*>(&hxs[i]), sizeof(float));
        out.write(reinterpret_cast<const char*>(&hys[i]), sizeof(float));
        out.write(reinterpret_cast<const char*>(&hzs[i]), sizeof(float));
    }
    // close the file
    out.close();
    std::cout << std::format("wrote {} vertices to {} using {} endian floats",
        N, path.c_str(), endianess)
              << std::endl;
};