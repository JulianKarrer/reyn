#ifndef SCENE_SAMPLE_CUH_
#define SCENE_SAMPLE_CUH_

#include <thrust/device_vector.h>
#include "loader.h"
#include "../buffer.cuh"
#include "datastructure/uniformgrid.cuh"

/// @brief Structure containing the positions of boundary samples in SoA format
/// (one seperate `DeviceBuffer` for each of the three components)
struct BoundarySamples {
    DeviceBuffer<float> xs;
    DeviceBuffer<float> ys;
    DeviceBuffer<float> zs;
};

/// @brief Relax a uniformly random boudnary sampling in the sense that samples
/// should spread out across each face of the mesh evenly to produce a
/// low-discrepancy, blue noise sampling. This method may be called repeatedly
/// to iteratively achieve a more even sampling.
///
/// The function uses SPH to estimate and minimize number density similar to how
/// pressure forces in the fluid minimize density deviations, except negative
/// "pressure" is allowed, stiffness is one, all masses are one and instead of a
/// time step that is integrated over, a scale-dependent particle shift is
/// calculated, before that shift is projected back onto the closest point on
/// the triangle that each sample was created on. This may lead to problems with
/// meshes that consist of triangles much smaller than the boundary sampling,
/// since their ability to spread out is limited by the projection step.
/// @param samples the `BoundarySamples` to relax - this  is modified by the
/// function.
/// @param grid_builder `UniformGridBuilder` for creating a datastructure
/// accelerating the search for neighbouring boundary samples
/// @param vxs x-component of all vertices in the sampled triangle mesh
/// @param vys y-component of all vertices in the sampled triangle mesh
/// @param vzs z-component of all vertices in the sampled triangle mesh
/// @param faces faces of the sampled triangle mesh, where each face is a
/// `uint3` of indices into the vertex buffers
/// @param h_bdy desired spacing of boundary particles
/// boundary particles
/// @param tri_ids the indices of the faces that each boundary sample was
/// created on
/// @param num_den a temporary buffer to store the intermediate number densities
/// computed during relaxation
/// @param relaxation_factor factor akin to the stiffness in the pressure solver
/// that determines the magnitude of the particle shift per iteration. Should be
/// a relatively scale-independent constant, since number densities are
/// normalized by the expected volume of a boundary particle if it were sampled
/// on a regular 3D grid (???: a plane might be a better assumption to make this
/// dimensionless).
void sample_relaxation(BoundarySamples& samples,
    UniformGridBuilder& grid_builder, thrust::device_vector<double> vxs,
    thrust::device_vector<double> vys, thrust::device_vector<double> vzs,
    thrust::device_vector<uint3> faces, float h_bdy,
    thrust::device_vector<int> tri_ids, thrust::device_vector<float>& num_den,
    const float relaxation_factor);

/// @brief Place boundary samples uniformly randomly on the surface of the given
/// `Mesh` with a spacing indicated by `h / oversampling_factor`.
///
/// Internally computes the area of each triangle, transforms it into a discrete
/// CDF using an inclusive prefix sum and uses stratified uniform sampling to
/// select a triangle to place each sample in, then uniformly randomly samples
/// that triangle - this should result in a uniform distribution of samples over
/// the area that matches the expected number of samples required to uphold the
/// desired spacing. The discrapancy of this uniform sampling might be
/// undesirable, so by specifying an iterative relaxation procedure
/// is conducted as described in the function `sample_relaxation`
/// @param mesh input mesh as generated by `load_mesh_from_obj`
/// @param h fluid particle spacing
/// @param oversampling_factor factor between particle spacing `h` and the
/// desired spacing of boudnary particles, where a higher factor results in
/// more samples
/// @param debug_stream an optional `std::ostream` pointer to write debug
/// information about the convergence of the relaxation procedure in csv format
/// to
/// @param relaxation_iters maximum number of iterations of the relaxation
/// procedure
/// @param relaxation_stiffness stiffness coefficient for the relaxation
/// procedure. Should be roughly in (0; 1.5]
/// @return collection of coordinates of boundary samples
BoundarySamples sample_mesh(const Mesh mesh, const float h,
    const double oversampling_factor = 2.0,
    std::ostream* debug_stream = nullptr, const int relaxation_iters = 50,
    const float relaxation_stiffness = 1.);

#endif // SCENE_SAMPLE_CUH_