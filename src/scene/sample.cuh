#ifndef SCENE_SAMPLE_CUH_
#define SCENE_SAMPLE_CUH_

#include "scene/loader.h"
#include "buffer.cuh"
#include <thrust/device_vector.h>

/// @brief Structure containing the positions of boundary samples in SoA format
/// (one seperate `DeviceBuffer` for each of the three components)
struct BoundarySamples {
    DeviceBuffer<float> xs;
    DeviceBuffer<float> ys;
    DeviceBuffer<float> zs;
};

/// @brief Place boundary samples uniformly randomly on the surface of the given
/// `Mesh` with a spacing indicated by `h / oversampling_factor`.
///
/// Internally computes the area of each triangle, transforms it into a discrete
/// CDF using an inclusive prefix sum and uses stratified uniform sampling to
/// select a triangle to place each sample in, then uniformly randomly samples
/// that triangle - this should result in a uniform distribution of samples over
/// the area that matches the expected number of samples required to uphold the
/// desired spacing. The discrapancy of this uniform sampling might be
/// undesirable, so further transformations, a high rate of oversampling or a
/// different sampling strategy is required to fill potential "gaps" in the
/// sampling
/// @param mesh input mesh as generated by `load_mesh_from_obj`
/// @param h particle spacing
/// @param oversampling_factor factor between particle spacing `h` and the
/// desired spacing of boudnary particles,  where a higher factor results in
/// more samples
/// @return collection of coordinates of boundary samples
BoundarySamples sample_mesh(
    const Mesh mesh, const float h, const double oversampling_factor = 2.0);

#endif // SCENE_SAMPLE_CUH_