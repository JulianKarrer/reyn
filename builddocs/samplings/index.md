# Relaxed Boundary Sampling

Uniform samplings can be generated: 
- Read mesh with `double` precision
- Compute accurate area of each triangle 
- Inclusive prefix sum gives discrete CDF
- Stratified inversion sampling to select a triangle to sample
- Uniformly sample that triangle


$\mathcal{O}(N)$, all steps except for loading the mesh into memory are perfectly parallelizable and minimum possible memory is required, since only the exact number of desired boundary particle positions must be held in memory (unlike some Poisson sampling methods etc.). `curand` can be used for efficient PRNG.

The sampling is robust for any mesh resolution and geometry, but may have undesirably high discrepancy and require significant oversampling compared to fluid spacing $h$ to achieve literally watertight results. 

## Relaxing the Sampling to Blue Noise

- Idea: use SPH number density as a cost function, use SPH gradient to minimize it by gradient descent, calculating a 3D particle shift, then project the shifted position back onto the triangular mesh. Iterate to convergence. This method allows using implemented SPH datastructures.

- Similarly to Jian et al in "Blue Noise Sampling using an SPHâ€“based Method"

Algorithm:
- Build datastructure for fixed radius neighbourhood query
- Build LBVH for closest point on mesh queries
- Compute number density $\hat{\rho}_i = \sum_{j\in\mathcal{N}_i} W(\vec{x}_{ij})$ (like density but with $\forall i: m_i=1$)
- Use symmetric gradient formula to shift particles in direction of negative number density gradient $-\nabla\hat{\rho}_i = - k \cdot h_{bdy}^2 \sum_{j\in\mathcal{N}_i} \left( \frac{\hat{\rho}_i}{\hat{\rho}_0^2} + \frac{\hat{\rho}_j}{\hat{\rho}_0^2}\right) \nabla W\left(\vec{x}_{ij}\right)$ 
    - The coefficient $h_{bdy}^2$ makes this invariant to scene size and sampling scale
    - A reference number density $\hat{\rho}_0$ for a normal, 3D SPH kernel function with a hexagonally close packed sampling on the plane with spacing $h_{bdy}$ can be computed for smoothing length $2h_{bdy}$ as: $\hat{\rho}_0(W,h_{bdy}) = \sum_{q=-2}^2 \sum_{r=-2}^2 W(q \cdot \vec{q}_b + r\cdot \vec{r}_b)$ with lattice vectors: $\vec{q}_b = h_{bdy} \begin{bmatrix}1\\0\\0\end{bmatrix}$ and $\vec{r}_b = h_{bdy} \begin{bmatrix}0.5\\0.5\sqrt{3}\\0\end{bmatrix}$
- Relaxation Coefficient $k=1$ appears close to optimal across all length scales, see plots below
- Project shifted particle to closest point on triangle mesh (see "Real-Time Collision Detection" by Christer Ericson for closest point on triangle + stack-based LBVH traversal for finding the closest point on the entire mesh)
- Repeat for a few iterations (on the order of 10, a couple of milliseconds of runtime for millions of particles on consumer GPU)

Caveats:
- For reasonable choice of $k$, quality improvement is lower-bound by initial, uniform random sampling.
- Thanks to the LBVH, now works on meshes of any resolution, even resolutions mush greater than that of the fluid, and for near-degenerate triangles.
- Race conditions on write for particle shifts are not prevented via seperate write buffer (with memory cost) but seen as a perk (Gauss-Seidel > Jacobi). 
- Minimizing 3D, euclidean number density instead of maximizing geodesic distance on mesh is also not only faster but in this case might be desired.

Appears to be a very cheap and effective way to get blue noise samplings with minimal memory cost, as shown for the Stanford dragon model (20.1k samples, 871.4k triangles) with many small triangles and non-convex features and test cube (38.4k samples, 12 triangles) with large, flat areas in the following. 

The following point clouds and graphs were auto-generated by REYN and exported using the script that constructed this website. Larger scenes with millions of samples were tested, but are less suitable for showcasing on the web.

## Uniform Sampling
Click and drag on any 3D viewer to adjust orbital controls, scroll to zoom.

<div class="samplingviewer statfixed" id="dragon_uniform"></div>

## Relaxed Sampling
<div class="samplingviewer statfixed" id="dragon_relaxed"></div>

## Side by Side Comparison
<div class="sidebyside-container" id="cube_container">
    <div class="sidebyside statfixed" id="cube_uniform" style="border-right: while 2px solid;"></div>
    <div class="sidebyside statfixed" id="cube_relaxed"></div>
</div>

## Convergence and Relaxation Coefficient
Convergence can be tracked by the ratio of highest to lowest number density across all boundary particles: $1$ is perfect, uniform sampling can be closer to $10\times$. Relaxation coefficient $k=1$ robustly and quickly converges, hence is set as default in implementation. The $2\times 2$ cube scene serves as input for the following measurements.


<div id="plots"></div>


<!-- three js scripts from here on  -->
<script id="vshader" type="x-shader/x-vertex">
    precision highp float;
    uniform mat4 modelViewMatrix;
    uniform mat4 projectionMatrix;

    attribute vec3 position;
    attribute vec2 uv;
    attribute vec3 translate;

    varying vec2 vUv;

    void main() {
        vUv = uv;
        vec4 mvPosition = modelViewMatrix * vec4( translate, 1.0 );
        float scale = 0.01;
        mvPosition.xyz += position * scale;
        gl_Position = projectionMatrix * mvPosition;

    }
</script>
<script id="fshader" type="x-shader/x-fragment">
    precision highp float;

    varying vec2 vUv;

    void main() {
        vec2 c = vUv - vec2(0.5);
        float radius = 1.0;
        float edge = 0.005;
        float dist = length(c);
        float alpha = 1.0 - smoothstep(radius - edge, radius + edge, dist);
        if (alpha <= 0.001) discard;
        gl_FragColor = vec4(1.0, 1.0, 1.0, alpha);
    }
</script>

<script type="importmap">
{
    "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.181.0/build/three.module.js",
        "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.181.0/examples/jsm/"
    }
}
</script>

<style>
.samplingviewer{
    width: 100%; height: 600px; position:relative;
}
.statfixed > div{ position: absolute !important; }
.sidebyside-container{
    width:100%; height:600px; position:relative;
    display:flex; flex-direction:row;
}
.sidebyside{
    width:50%; height:100%; position:relative;
}
</style>
<script type="module">
    import * as THREE from 'three';

    import Stats from 'three/addons/libs/stats.module.js';
    import { PLYLoader } from 'three/addons/loaders/PLYLoader.js'
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

    let cube_container = document.getElementById("cube_container")
    let cube_camera =  new THREE.PerspectiveCamera(50, 0.5*cube_container.clientWidth / cube_container.clientHeight, 0.01, 100);
    cube_camera.position.z = 5;
    let cube_controls = new OrbitControls(cube_camera, cube_container)
    cube_controls.enableDamping = true

    init('cube_uniform', 5, cube_camera, cube_controls, cube_container);
    init('cube_relaxed', 5, cube_camera, cube_controls, cube_container);

    init('dragon_uniform', 3);
    init('dragon_relaxed', 3);

    function init(plyname, init_z=5, camera=null, controls=null, dom_elem=null) {
        let container, stats;

        let scene, renderer;
        let geometry, material, mesh;

        // add to html DOM
        container = document.getElementById(plyname);

        let onWindowResize = () => {
            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(container.clientWidth, container.clientHeight);
        }

        let animate = () => {
            controls.update()
            renderer.render(scene, camera);
            stats.update();
        }


        // set up scene
        if (!camera){
            camera = new THREE.PerspectiveCamera(50, container.clientWidth / container.clientHeight, 0.01, 100);
        }
        camera.position.z = init_z;
        scene = new THREE.Scene();

        // load sprite for billboarding
        const sprite = new THREE.TextureLoader().load('../_static/circle.png');
        sprite.colorSpace = THREE.SRGBColorSpace;

        // load particles
        const loader = new PLYLoader()
        loader.load(
            '../_static/' + plyname + '.ply',
            function (geometry) {
                geometry.computeVertexNormals()
                const material = new THREE.PointsMaterial({
                    size: 0.05,
                    sizeAttenuation: true,
                    map: sprite,
                    alphaTest: 0.5,
                    transparent: true
                });
                const points = new THREE.Points(geometry, material);
                scene.add(points);
            },
            (xhr) => {
                console.log((xhr.loaded / xhr.total) * 100 + '% loaded')
            },
            (error) => {
                console.log(error)
            }
        )

        // set up renderer
        renderer = new THREE.WebGLRenderer();
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(container.clientWidth, container.clientHeight);
        renderer.setAnimationLoop(animate);
        window.addEventListener('resize', onWindowResize);
        container.appendChild(renderer.domElement);

        // enable orbital controls
        if (!controls){
            controls = new OrbitControls(camera, dom_elem ? dom_elem : renderer.domElement)
        }
        controls.enableDamping = true
        // show stats
        stats = new Stats();
        document.getElementById(plyname).appendChild(stats.dom);
    }
</script>


<!-- plotting  -->
<script src="../_static/plotly-2.26.0.min.js"></script>
<style>
    .plot-container {
        filter: invert(90%) hue-rotate(180deg);
    }
</style>
<script type="module">
    const prefix = "../_static/relaxconv/";
    const desc = await fetch(prefix + "description.json").then(r => r.json());
    const byH = {};
    for (const t of desc.traces) (byH[t.h_bdy] ??= []).push(t);
    for (const [h, arr] of Object.entries(byH)) {
        const div = document.createElement("div");
        div.style.width = "100%";
        div.style.height = "500px";
        document.getElementById("plots").appendChild(div);
        const title = `${arr[0].count} Particles, Boundary Particle Spacing = ${h}`;
        const traces = await Promise.all(arr.map(async t => {
            const txt = await fetch(prefix + t.filename).then(r => r.text());
            const lines = txt.trim().split(/\n/).map(l => l.split(/,|\s+/).map(Number));
            return { x: lines.map(l => l[0]), y: lines.map(l => l[1]), name: `k=${t.k}`, mode: 'lines' };
        }));
        Plotly.newPlot(div, traces, {
            template: 'plotly_dark',
            title, height: 500,
            xaxis: { title: 'Number of Iterations' },
            yaxis: { title: 'Ratio Maximum/Minimum Number Density' }
        });
    }
</script>